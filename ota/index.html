# å°ˆæ¡ˆæ¨¹èˆ‡èªªæ˜ï¼ˆç¬¬ä¸€ç‰ˆ MVP / å¯é©—è­‰ç‰ˆï¼‰

```
EASY_THRUSTER/
â”œâ”€ app/
â”‚  â””â”€ index.html                 # æ‰‹æ©Ÿç«¯ï¼ˆBluefy é¢¨æ ¼ï¼‰Webâ€‘Bluetoothï¼šé€£ NUSã€è®€/å¯« FFF4ã€æ›²ç·šç·¨è¼¯
â”œâ”€ BLE_CAN_M/                    # ä¸»æ§ï¼šPico 2W + CAN æ¨¡çµ„ï¼ˆSPI0ï¼›å¯åˆ‡æ› SIM_CAN æ¨¡å¼ï¼‰
â”‚  â”œâ”€ ble_can_m_main.py          # ä¸»ç¨‹å¼ï¼šBLE NUS Peripheral + FFF4 ç‰¹å¾µ + OBD è¼ªè©¢ + å¿ƒè·³
â”‚  â”œâ”€ can_obd.py                 # OBDâ€‘II è¼ªè©¢/è§£æï¼ˆ010C/0111/010Bï¼‰ï¼Œå°è£è®€å¯« & æ¨¡æ“¬
â”‚  â”œâ”€ mcp2515.py                 # MCP2515 SPI é©…å‹•ï¼ˆæœ€å°å¯ç”¨é›†ï¼‰
â”‚  â””â”€ cfg_default.json           # FFF4 çš„é è¨­æ›²ç·š/æ¿¾æ³¢/failsafe
â””â”€ AT_ble/                       # åŸ·è¡Œå™¨ï¼šPico + 2340AQ2ï¼ˆUART AT/RAWï¼‰
   â””â”€ pico_ble_bridge_qa2.py     # ç©©å®šæ©‹æ¥ç‰ˆï¼ˆBRTS=GP13ãƒ»ä¸‰æ¨¡å¼ï¼‰ï¼‹å‘½ä»¤è§£æï¼ˆLED/PWMï¼‰ï¼‹çœ‹é–€ç‹—
```

> èªªæ˜ï¼šç‚ºä¾¿æ–¼ä½ å¿«é€Ÿé©—è­‰ï¼Œæœ¬ç‰ˆ **BLE_CAN_M** å…ˆæä¾›å®Œæ•´ **Peripheralï¼ˆå°æ‰‹æ©Ÿï¼‰** + **CAN è¼ªè©¢** èˆ‡ **FFF4**ï¼Œ
> ã€ŒCentralï¼ˆå° AT bleï¼‰ã€æŠ½è±¡æˆ `ActuatorLink` ä»‹é¢ï¼Œé è¨­ç‚º **LOOPBACK æ¨¡å¼**ï¼ˆå…ˆç›´æ¥åœ¨ä¸»æ§ä¸Šè¼¸å‡º PWM/LED åšé–‰ç’°é©—è­‰ï¼‰ã€‚
> å¾ŒçºŒåªè¦æŠŠ `ActuatorLink` çš„ `send_pwm/led_on/led_off/hb` é€£æ¥åˆ° **Centralâ€‘BLE å¯¦ä½œ** å³å¯ç„¡ç—›åˆ‡æ›ã€‚

---

## app/index.html

```html
<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EASY THRUSTER Â· App</title>
  <style>
    :root { --bg:#0b0f17; --card:#121826; --txt:#e8eefc; --muted:#98a2b3; --acc:#66d9ff; }
    html,body{height:100%;background:var(--bg);color:var(--txt);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
    .wrap{max-width:980px;margin:0 auto;padding:20px}
    .row{display:grid;gap:16px}
    .grid-2{grid-template-columns:1fr 1fr}
    .card{background:var(--card);border-radius:16px;padding:16px;box-shadow:0 4px 24px rgba(0,0,0,.25)}
    h1{margin:8px 0 16px;font-size:24px}
    button{background:var(--acc);color:#001018;border:0;border-radius:12px;padding:10px 14px;font-weight:600;cursor:pointer}
    input,textarea{width:100%;background:#0e1422;color:var(--txt);border:1px solid #1f2b44;border-radius:10px;padding:10px}
    .badge{display:inline-block;padding:4px 8px;border-radius:999px;background:#0f2236;color:#a5d9ff;border:1px solid #1f3652}
    .row-kv{display:grid;grid-template-columns:120px 1fr;gap:8px;align-items:center}
    .log{height:180px;overflow:auto;font-family:ui-monospace,Consolas,monospace;font-size:12px;white-space:pre-wrap}
    .pts{display:flex;gap:8px;flex-wrap:wrap}
    .pts input{width:70px}
  </style>
</head>
<body>
<div class="wrap">
  <h1>EASY THRUSTER <span class="badge" id="state">æœªé€£ç·š</span></h1>
  <div class="row grid-2">
    <div class="card">
      <h3>é€£ç·š</h3>
      <button id="btnConnect">é€£ç·šä¸»æ§ï¼ˆBLE_CAN_Mï¼‰</button>
      <button id="btnDisconnect">æ–·ç·š</button>
      <div class="row-kv"><span>è£ç½®ï¼š</span><span id="dev"></span></div>
      <div class="row-kv"><span>å¿ƒè·³ï¼š</span><span id="hb">--</span></div>
    </div>

    <div class="card">
      <h3>å³æ™‚é™æ¸¬</h3>
      <div class="row-kv"><span>RPM</span><input id="rpm" readonly></div>
      <div class="row-kv"><span>Throttle %</span><input id="th" readonly></div>
      <div class="row-kv"><span>MAP</span><input id="map" readonly></div>
      <div class="row-kv"><span>Diag</span><input id="diag" readonly></div>
    </div>

    <div class="card">
      <h3>æ§åˆ¶</h3>
      <div class="row-kv"><span>Fan %</span><input id="fan" type="number" min="0" max="100" value="30"></div>
      <div class="row" style="margin-top:8px">
        <button id="btnSend">ä¸‹ç™¼ FAN%</button>
        <button id="btnLedOn">LED ON</button>
        <button id="btnLedOff">LED OFF</button>
      </div>
    </div>

    <div class="card">
      <h3>CFG æ›²ç·šï¼ˆFFF4ï¼‰</h3>
      <div class="pts" id="pts"></div>
      <div class="row" style="margin-top:8px">
        <button id="btnReadCfg">è®€å–</button>
        <button id="btnWriteCfg">å¯«å…¥</button>
      </div>
    </div>

    <div class="card" style="grid-column:1/-1">
      <h3>æ—¥èªŒ</h3>
      <div class="log" id="log"></div>
    </div>
  </div>
</div>
<script>
const NUS_SERVICE = "6e400001-b5a3-f393-e0a9-e50e24dcca9e";
const NUS_RX =      "6e400003-b5a3-f393-e0a9-e50e24dcca9e"; // notify
const NUS_TX =      "6e400002-b5a3-f393-e0a9-e50e24dcca9e"; // write
const FFF4_UUID =   0xFFF4; // readable + writable JSON

let device, gatt, nusSvc, chTx, chRx, chCfg;
let pingTimer, lastPong = 0;

function log(s){ const el=document.getElementById('log'); el.textContent += s+"\n"; el.scrollTop = el.scrollHeight; }
function setState(s){ document.getElementById('state').textContent = s; }
function enc(s){ return new TextEncoder().encode(s); }
function dec(b){ return new TextDecoder().decode(b); }

async function connect(){
  device = await navigator.bluetooth.requestDevice({
    filters:[{ services:[NUS_SERVICE] }], optionalServices:[FFF4_UUID]
  });
  device.addEventListener('gattserverdisconnected', onDisc);
  gatt = await device.gatt.connect();
  nusSvc = await gatt.getPrimaryService(NUS_SERVICE);
  chTx = await nusSvc.getCharacteristic(NUS_TX);
  chRx = await nusSvc.getCharacteristic(NUS_RX);
  await chRx.startNotifications();
  chRx.addEventListener('characteristicvaluechanged', ev=> onNus(dec(ev.target.value.buffer)));
  const svcCfg = await gatt.getPrimaryService(FFF4_UUID);
  const chars = await svcCfg.getCharacteristics();
  chCfg = chars[0]; // å–®ä¸€ FFF4
  document.getElementById('dev').textContent = device.name || '(ç„¡åç¨±)';
  setState('å·²é€£ç·š');
  log('âœ… å·²é€£ç·š');
  startPing();
}

function onDisc(){ setState('æœªé€£ç·š'); log('ğŸ”Œ å·²æ–·ç·š'); stopPing(); }

function startPing(){
  stopPing();
  lastPong = Date.now();
  pingTimer = setInterval(()=>{
    sendLine('PING');
    const diff = Math.round((Date.now()-lastPong)/1000);
    document.getElementById('hb').textContent = diff+' s';
    if(diff>=3) document.getElementById('state').textContent = 'å¿ƒè·³é€¾æ™‚ï¼ˆUIï¼‰';
  }, 1000);
}
function stopPing(){ if(pingTimer) clearInterval(pingTimer); }

function sendLine(s){ if(!chTx) return; log('â†’ '+s); return chTx.writeValue(enc(s+'\n')); }

function onNus(s){
  s = s.trim(); if(!s) return; log('â† '+s);
  if(s.startsWith('PONG')){ lastPong = Date.now(); document.getElementById('state').textContent='å·²é€£ç·š'; return; }
  try{
    const j = JSON.parse(s);
    if('rpm' in j) document.getElementById('rpm').value = j.rpm;
    if('th' in j)  document.getElementById('th').value  = j.th;
    if('map' in j) document.getElementById('map').value = j.map;
    if('diag' in j)document.getElementById('diag').value= j.diag;
  }catch{ /* ignore */ }
}

// CFG
async function readCfg(){
  const v = await chCfg.readValue();
  const txt = dec(v.buffer);
  log('CFG â† '+txt); renderPoints(JSON.parse(txt));
}
async function writeCfg(){
  const cfg = collectPoints();
  const txt = JSON.stringify(cfg);
  log('CFG â†’ '+txt);
  await chCfg.writeValue(enc(txt));
}

function renderPoints(cfg){
  const box = document.getElementById('pts'); box.innerHTML='';
  const pts = cfg.points || [[0,0],[50,50],[100,100]];
  pts.forEach((p,i)=>{
    const x = document.createElement('input'); x.type='number'; x.min=0; x.max=100; x.value=p[0]; x.id='x'+i;
    const y = document.createElement('input'); y.type='number'; y.min=0; y.max=100; y.value=p[1]; y.id='y'+i;
    box.appendChild(x); box.appendChild(y);
  });
}
function collectPoints(){
  const box = document.getElementById('pts');
  const inputs = [...box.querySelectorAll('input')];
  const pts=[]; for(let i=0;i<inputs.length;i+=2){ pts.push([+inputs[i].value, +inputs[i+1].value]); }
  // å¤¾å–/æ’åº
  pts.sort((a,b)=>a[0]-b[0]);
  pts.forEach(p=>{ p[0]=Math.min(100,Math.max(0,p[0])); p[1]=Math.min(100,Math.max(0,p[1])); });
  return {ver:1, points:pts, failsafe:{lost_master_secs:2.5,fallback_pwm:20}, filter:{alpha:0.3}};
}

// UI ç¶å®š
btnConnect.onclick = connect;
btnDisconnect.onclick = ()=> device?.gatt?.disconnect();
btnSend.onclick = ()=> sendLine('CTRL: FAN='+(+document.getElementById('fan').value|0)+'%');
btnLedOn.onclick = ()=> sendLine('CTRL: LED ON');
btnLedOff.onclick = ()=> sendLine('CTRL: LED OFF');
btnReadCfg.onclick = readCfg;
btnWriteCfg.onclick = writeCfg;

renderPoints(collectPoints());
</script>
</body>
</html>
```

---

## BLE_CAN_M/ble_can_m_main.py

```python
# MicroPython (Pico 2W) â€” BLE NUS Peripheral + FFF4 + OBD æ¨¡æ“¬/å¯¦æ©Ÿåˆ‡æ› + å¿ƒè·³
import ujson, utime, machine
from machine import Pin, PWM
try:
    import ubluetooth as bluetooth
except ImportError:
    import bluetooth

from can_obd import OBDReader

# ====== åƒæ•¸å€ ======
SIM_CAN = True   # æ²’æ¥ MCP2515 æ™‚å…ˆç”¨æ¨¡æ“¬
PWM_PIN = 6      # LOOPBACK æ¸¬è©¦ï¼šç”¨ Pico 2W è‡ªå·±çš„ PWM å…ˆé©…å‹•é¢¨æ‰‡/LED
LED_PIN = 25     # æ¿è¼‰ LED æŒ‡ç¤º
HB_INTERVAL_MS = 1000
AT_TIMEOUT_MS = 2500  # çµ¦ actuator çš„æ§åˆ¶è¶…æ™‚ï¼ˆLOOPBACK å³è‡ªç”¨ï¼‰

# NUS & FFF4 UUID
_UUID_NUS  = bluetooth.UUID("6e400001-b5a3-f393-e0a9-e50e24dcca9e")
_UUID_TX   = bluetooth.UUID("6e400003-b5a3-f393-e0a9-e50e24dcca9e")
_UUID_TX_CH= ( _UUID_TX, bluetooth.FLAG_NOTIFY )
_UUID_RX   = bluetooth.UUID("6e400002-b5a3-f393-e0a9-e50e24dcca9e")
_UUID_RX_CH= ( _UUID_RX, bluetooth.FLAG_WRITE )
_UUID_CFG  = bluetooth.UUID(0xFFF4)
_UUID_CFG_CH=( _UUID_CFG, bluetooth.FLAG_READ | bluetooth.FLAG_WRITE )

# ====== Actuator é€£çµï¼ˆæŠ½è±¡ï¼‰â€” å…ˆ LOOPBACK åˆ°æœ¬åœ° PWM/LED ======
class ActuatorLink:
    def __init__(self, pwm_pin=PWM_PIN, led_pin=LED_PIN):
        self.led = Pin(led_pin, Pin.OUT)
        self.pwm = PWM(Pin(pwm_pin))
        self.pwm.freq(1000)
        self.last_cmd_ms = utime.ticks_ms()
        self.current = 0
    def send_pwm(self, pct:int):
        pct = max(0, min(100, int(pct)))
        self.current = pct
        duty = int(pct*65535/100)
        self.pwm.duty_u16(duty)
        self.last_cmd_ms = utime.ticks_ms()
    def led_on(self):
        self.led.value(1); self.last_cmd_ms = utime.ticks_ms()
    def led_off(self):
        self.led.value(0); self.last_cmd_ms = utime.ticks_ms()
    def heartbeat(self):
        # é ç•™ï¼šCentral BLE å¯åœ¨æ­¤é€ HB å°åŒ…çµ¦ AT ble
        pass
    def check_timeout(self, ms=AT_TIMEOUT_MS, fallback=20):
        if utime.ticks_diff(utime.ticks_ms(), self.last_cmd_ms) > ms:
            self.send_pwm(fallback)

# ====== CFG ç®¡ç† ======
_DEFAULT_CFG = {
    "ver": 1,
    "points": [[0,0],[20,20],[40,35],[60,55],[80,78],[100,100]],
    "failsafe": {"lost_master_secs":2.5, "fallback_pwm":20},
    "filter": {"alpha":0.3}
}

class CfgStore:
    def __init__(self, path='cfg_default.json'):
        self.path = path
        self.cfg = _DEFAULT_CFG
        try:
            with open(path) as f:
                self.cfg = ujson.loads(f.read())
        except:
            pass
    def read_json(self):
        return self.cfg
    def write_json(self, obj):
        self.cfg = obj
        try:
            with open(self.path,'w') as f: f.write(ujson.dumps(obj))
        except: pass

# ====== BLE Peripheral ======
class NUSPeripheral:
    def __init__(self, name="BLE_CAN_M"):
        self._ble = bluetooth.BLE(); self._ble.active(True)
        self._ble.irq(self._irq)
        self._connections = set()
        self._name = name
        TX = (_UUID_TX, bluetooth.FLAG_NOTIFY)
        RX = (_UUID_RX, bluetooth.FLAG_WRITE)
        CFG= (_UUID_CFG, bluetooth.FLAG_READ | bluetooth.FLAG_WRITE)
        self._handle_tx = None; self._handle_rx = None; self._handle_cfg=None
        self._services = (( _UUID_NUS, (TX, RX) ), ( _UUID_CFG, (CFG,) ))
        ((self._tx_handle, self._rx_handle), (self._cfg_handle,)) = self._ble.gatts_register_services([
            (_UUID_NUS, (TX, RX)), (_UUID_CFG, (CFG,))
        ])
        self._ble.gatts_write(self._cfg_handle, ujson.dumps(_DEFAULT_CFG))
        self._payload = bluetooth.advertising_payload(name=name, services=[_UUID_NUS]) if hasattr(bluetooth,'advertising_payload') else None
        self._adv()
        self.on_rx = None
    def _adv(self):
        try:
            from micropython import const
            ADV_IND = const(0x00)
            self._ble.gap_advertise(100_000, adv_data=self._payload)
        except Exception:
            self._ble.gap_advertise(100_000)
    def _irq(self, event, data):
        if event == 1: # _IRQ_CENTRAL_CONNECT
            conn_handle, _, _ = data
            self._connections.add(conn_handle)
        elif event == 2: # _IRQ_CENTRAL_DISCONNECT
            conn_handle, _, _ = data
            self._connections.discard(conn_handle)
            self._adv()
        elif event == 3: # _IRQ_GATTS_WRITE
            conn_handle, value_handle = data
            if value_handle == self._rx_handle:
                raw = self._ble.gatts_read(self._rx_handle)
                if self.on_rx: self.on_rx(raw)
            elif value_handle == self._cfg_handle:
                # å®¢æˆ¶ç«¯å¯«å…¥æ–° CFG
                pass
    def send_text(self, s:str):
        for h in self._connections:
            try: self._ble.gatts_notify(h, self._tx_handle, s)
            except: pass
    def read_cfg(self):
        return self._ble.gatts_read(self._cfg_handle)
    def write_cfg(self, b):
        self._ble.gatts_write(self._cfg_handle, b)

# ====== ä¸»æµç¨‹ ======
led = Pin(LED_PIN, Pin.OUT)
act = ActuatorLink()
cfg = CfgStore()

# OBD è®€å–
obd = OBDReader(sim=SIM_CAN)

ble = NUSPeripheral("BLE_CAN_M")

def parse_line(line:str):
    line = line.strip()
    if not line: return
    if line == 'PING':
        ble.send_text('PONG')
        return
    if line.startswith('CTRL:'):
        # CTRL: FAN=55% / LED ON / LED OFF
        body = line[5:].strip()
        if body.startswith('FAN='):
            try:
                val = int(body.split('=')[1].replace('%','').strip())
                act.send_pwm(val)
            except: pass
        elif 'LED ON' in body:
            act.led_on()
        elif 'LED OFF' in body:
            act.led_off()
        return
    if line.startswith('SAVE:CFG'):
        cfg.write_json(ujson.loads(ble.read_cfg()))
        return

ble.on_rx = lambda raw: parse_line(raw.decode())

last_hb = utime.ticks_ms()
alpha = cfg.read_json().get('filter',{}).get('alpha',0.3)
fan_pct = 0

while True:
    # å¿ƒè·³ï¼ˆä¸Šè¡Œ JSONï¼‰
    if utime.ticks_diff(utime.ticks_ms(), last_hb) >= HB_INTERVAL_MS:
        j = obd.read_once()  # {rpm, th, map, kbps, diag}
        # ç”¨æ›²ç·šæŠŠ throttle -> fan ç›®æ¨™
        pts = cfg.read_json().get('points', _DEFAULT_CFG['points'])
        th = j.get('th',0)
        # ç·šæ€§æ’å€¼
        tgt = 0
        for i in range(len(pts)-1):
            if pts[i][0] <= th <= pts[i+1][0]:
                x0,y0 = pts[i]; x1,y1 = pts[i+1]
                if x1==x0: tgt=y1
                else: tgt = y0 + (y1-y0)*(th-x0)/(x1-x0)
                break
        # æ¿¾æ³¢
        fan_pct = alpha*tgt + (1-alpha)*fan_pct
        act.send_pwm(int(fan_pct))

        j['diag'] = 'ok'
        ble.send_text(ujson.dumps(j))
        ble.send_text('\n')
        last_hb = utime.ticks_ms()
    # å¤±è¯ä¿è­·ï¼ˆå°åŸ·è¡Œå™¨ï¼‰
    act.check_timeout(ms=int(cfg.read_json()['failsafe']['lost_master_secs']*1000),
                      fallback=cfg.read_json()['failsafe']['fallback_pwm'])
    utime.sleep_ms(20)
```

---

## BLE_CAN_M/can_obd.py

```python
# OBD-II è¼ªè©¢/è§£æï¼ˆæ¨¡æ“¬æˆ– MCP2515ï¼‰
import utime, urandom
try:
    from mcp2515 import MCP2515
except ImportError:
    MCP2515 = None

class OBDReader:
    def __init__(self, sim=True, spi=None, cs_pin=5, int_pin=21, kbps=500):
        self.sim = sim or (MCP2515 is None)
        if not self.sim:
            self.can = MCP2515(spi=spi, cs_pin=cs_pin, int_pin=int_pin, kbps=kbps)
        self._t = 0
    def _sim_val(self):
        rpm = 900 + (urandom.getrandbits(10) % 2500)
        th  = urandom.getrandbits(7) % 100
        mapk= 90 + urandom.getrandbits(5)
        return {"rpm":rpm, "th":th, "map":mapk, "kbps":500, "ext":0}
    def read_once(self):
        if self.sim:
            j = self._sim_val(); j['diag'] = 'heartbeat'; return j
        # TODO: çœŸå¯¦ MCP2515 æŸ¥è©¢ 010C/0111/010B
        # self.can.request_pid(0x010C) ...
        return {"rpm":1000, "th":20, "map":100, "kbps":500, "ext":0, "diag":"stub"}
```

---

## BLE_CAN_M/mcp2515.pyï¼ˆæœ€å°å¯ç”¨æ¡¿ä»¶ï¼›å¯å¾ŒçºŒæ“´å……ï¼‰

```python
# MCP2515 Minimal for MicroPython on RP2040 (SPI0)
from machine import SPI, Pin
import utime

# å¯¦ä½œåƒ…å«åˆå§‹åŒ–/ä½å…ƒç‡è¨­å®šçš„éª¨æ¶ï¼›å¾ŒçºŒå†æ“´å…… TX/RX/PID helper
class MCP2515:
    def __init__(self, spi=None, cs_pin=5, int_pin=21, kbps=500):
        self.cs = Pin(cs_pin, Pin.OUT, value=1)
        self.int = Pin(int_pin, Pin.IN)
        self.spi = spi or SPI(0, baudrate=1_000_000, polarity=0, phase=0, bits=8, firstbit=SPI.MSB)
        self.reset(); self.set_bitrate(kbps); self.set_normal_mode()
    def _cs(self, v):
        self.cs.value(v)
    def _rw(self, b):
        self._cs(0); self.spi.write(b); self._cs(1)
    def reset(self):
        self._rw(bytes([0xC0]))  # RESET
        utime.sleep_ms(10)
    def set_bitrate(self, kbps):
        # ç°¡åŒ–ï¼šå‡è¨­ 16MHz æ™¶æŒ¯ï¼Œ500kbpsï¼ˆCNF1..3ï¼‰å¸¸æ•¸
        # 500kbps: CNF1=0x00, CNF2=0x90, CNF3=0x02 ï¼ˆåƒ…ç¤ºæ„ï¼‰
        if kbps==500:
            cnf1,cnf2,cnf3 = 0x00,0x90,0x02
        elif kbps==250:
            cnf1,cnf2,cnf3 = 0x01,0x90,0x02
        else:
            cnf1,cnf2,cnf3 = 0x03,0x90,0x02
        # Write registers starting at CNF3(0x28), CNF2(0x29), CNF1(0x2A) via WRITE(0x02)
        self._cs(0)
        self.spi.write(bytes([0x02, 0x2A, cnf1, 0x29, cnf2, 0x28, cnf3]))
        self._cs(1)
    def set_normal_mode(self):
        # Write CANCTRL (0x0F) to Normal (REQOP=000)
        self._cs(0)
        self.spi.write(bytes([0x02, 0x0F, 0x00]))
        self._cs(1)
```

---

## BLE_CAN_M/cfg_default.json

```json
{
  "ver": 1,
  "points": [[0,0],[20,20],[40,35],[60,55],[80,78],[100,100]],
  "failsafe": {"lost_master_secs": 2.5, "fallback_pwm": 20},
  "filter": {"alpha": 0.3}
}
```

---

## AT_ble/pico_ble_bridge_qa2.py

```python
# Pico + 2340AQ2ï¼ˆUART AT/RAWï¼‰æ©‹æ¥ + æŒ‡ä»¤è§£æï¼ˆLED/PWMï¼‰+ çœ‹é–€ç‹—
# å·²çŸ¥ç©©å®šé»ï¼šPIN_BRTS=13ï¼›æ”¯æ´ always-low / timed / gnd-external ä¸‰æ¨¡å¼ï¼›
# 'LED ON' / 'LED OFF' å‘½ä»¤ã€'PWM:<0..100>'ã€å¿ƒè·³ '.'

import machine, utime
from machine import Pin, PWM, UART

PIN_BRTS = 13   # BRTS æ§åˆ¶è…³ï¼ˆé è¨­ HIGH ç¦æ­¢ï¼›æ‹‰ä½å…è¨± MCUâ†’BLE æ¨¡çµ„ç™¼é€ï¼‰
PIN_LED  = 6    # ä¾‹ï¼šå¤–æ¥ LED æˆ–é¢¨æ‰‡æ§åˆ¶ PWM è…³ï¼ˆå¯ä¾æ¿å­èª¿æ•´ï¼‰
UART_TX  = 0    # GP0 â†’ æ¨¡çµ„ RX
UART_RX  = 1    # GP1 â† æ¨¡çµ„ TX
BAUD     = 115200

MODE = 'timed'  # 'always-low' | 'timed' | 'gnd-external'
BRTS_PULSE_MS = 5

uart = UART(0, baudrate=BAUD, tx=machine.Pin(UART_TX), rx=machine.Pin(UART_RX))
brts = Pin(PIN_BRTS, Pin.OUT, value=1)
led  = Pin(25, Pin.OUT)  # æ¿è¼‰ LED æŒ‡ç¤º
pwm  = PWM(Pin(PIN_LED)); pwm.freq(1000)

last_cmd_ms = utime.ticks_ms()
TIMEOUT_MS = 2500
FALLBACK_PWM = 20


def brts_enable_once():
    if MODE == 'always-low':
        brts.value(0)
    elif MODE == 'timed':
        brts.value(0); utime.sleep_ms(BRTS_PULSE_MS); brts.value(1)
    elif MODE == 'gnd-external':
        pass

def mcu_send_to_ble_string(s: str):
    brts_enable_once()
    uart.write(s)


def set_pwm_pct(pct:int):
    pct = max(0,min(100,int(pct)))
    duty = int(pct*65535/100)
    pwm.duty_u16(duty)


# ====== åˆå§‹åŒ–ï¼šé€² AT æ¨¡å¼ï¼Œé–‹å›é¡¯ï¼Œç¤ºä¾‹æŒ‡ä»¤ ======
print('Entering AT mode...')
mcu_send_to_ble_string(b'+++')
utime.sleep_ms(50)
# æ¨¡çµ„æœƒå› 'K' æˆ– 'OK'ï¼Œæ­¤è™•ç•¥éåŒæ­¥ç­‰å¾…ç°¡åŒ–
mcu_send_to_ble_string(b'AT+ECHO=1\r\n')
utime.sleep_ms(30)
print('Exit AT...')
mcu_send_to_ble_string(b'AT+EXIT\r\n')  # é€² RAW
utime.sleep_ms(30)
print('Ready. Type: \'+++\' / \'AT:<cmd>\' / \'SEND:<text>\'')


# ====== å‘½ä»¤è™•ç† ======

def process_line(s:str):
    global last_cmd_ms
    s = s.strip()
    if not s:
        return
    # å¿ƒè·³ï¼šå–®é» '.'
    if s == '.':
        last_cmd_ms = utime.ticks_ms(); return
    # LED / PWM æ§åˆ¶
    if s.upper().startswith('LED ON'):
        Pin(25, Pin.OUT).value(1)
        last_cmd_ms = utime.ticks_ms(); return
    if s.upper().startswith('LED OFF'):
        Pin(25, Pin.OUT).value(0)
        last_cmd_ms = utime.ticks_ms(); return
    if s.upper().startswith('PWM:'):
        try:
            v = int(s.split(':',1)[1])
            set_pwm_pct(v)
            last_cmd_ms = utime.ticks_ms(); return
        except: pass


buf = b''
while True:
    # è®€å–ä¾†è‡ªæ¨¡çµ„çš„è³‡æ–™ï¼ˆæˆ–ä¾†è‡ªä¸Šæ¸¸ä¸»æ§é€éæ¨¡çµ„è½‰ç™¼è€Œä¾†ï¼‰
    if uart.any():
        ch = uart.read(1)
        if ch:
            c = ch
            if c == b'\n':
                try:
                    process_line(buf.decode())
                except: pass
                buf = b''
            elif c not in (b'\r',):
                buf += c
    # çœ‹é–€ç‹—ï¼šé€¾æ™‚ â†’ é™è‡³ fallback PWM
    if utime.ticks_diff(utime.ticks_ms(), last_cmd_ms) > TIMEOUT_MS:
        set_pwm_pct(FALLBACK_PWM)
    utime.sleep_ms(5)
```
