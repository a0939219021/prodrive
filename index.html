<script>
/* 佇列化 TX：避免 “GATT operation already in progress” */
let txChain = Promise.resolve();
function queue(fn){
  txChain = txChain.then(fn).catch(e => log('TX ERR ' + (e?.message || e)));
  return txChain;
}
async function send(cmd){
  return queue(async ()=>{
    if (!chRX || !device?.gatt?.connected) throw new Error('尚未連線');
    const enc = new TextEncoder().encode(cmd);
    if (chRX.writeValueWithResponse) await chRX.writeValueWithResponse(enc);
    else                             await chRX.writeValue(enc);
    log('TX ' + cmd);
  });
}

/* ===== 驗證輪詢（含 in-flight 鎖與看門狗） ===== */
let verifyTimer=null, verifyInFlight=false, verifyWatch=null;
function startVerifyPoll(){
  stopVerifyPoll();
  // 立即觸發一次
  queue(async ()=>{ try{ await send('FW:STAT'); }catch(_){} });

  verifyTimer = setInterval(async ()=>{
    if (verifyInFlight) return;
    verifyInFlight = true;
    try { await send('FW:STAT'); } finally { verifyInFlight = false; }
  }, 1000); // 1s 查一次

  // 15 秒看門狗：沒有任何 fw end/abort 事件就提示逾時
  verifyWatch = setTimeout(()=>{
    $('#fwinfo').textContent = 'Verify timeout — 裝置未回覆，請重連後再按 “FW:STAT” 或重試 OTA';
    log('OTA WARN verify timeout — try reconnect then send FW:STAT');
    stopVerifyPoll();
  }, 15000);
}
function stopVerifyPoll(){
  if (verifyTimer){ clearInterval(verifyTimer); verifyTimer=null; }
  if (verifyWatch){ clearTimeout(verifyWatch); verifyWatch=null; }
  verifyInFlight=false;
}

/* ====== 通知處理：fw 事件時停掉輪詢 ====== */
function onNotify(ev){
  const dv = ev.target.value;
  let s = ""; for (let i=0;i<dv.byteLength;i++) s += String.fromCharCode(dv.getUint8(i));
  try{
    const j = JSON.parse(s);
    if (j.t === 'fw'){
      if (j.ev === 'begin'){
        if (j.ok){ $('#fwinfo').textContent = `Begin OK → target=${j.target} size=${j.size}`; $('#fwprog').value=0; }
        else { $('#fwinfo').textContent = `Begin ERR: ${j.err||''}`; }
      }else if (j.ev === 'progress'){
        if (j.size){ $('#fwprog').max=j.size; $('#fwprog').value=j.rx||0; }
        $('#fwinfo').textContent = `Uploading… ${j.rx}/${j.size}`;
      }else if (j.ev === 'verify'){
        $('#fwinfo').textContent = `Verifying… ${j.rx}/${j.size}`;
      }else if (j.ev === 'stat'){
        if (j.active){
          $('#fwinfo').textContent = `Waiting verify… ${j.rx}/${j.size}`;
          if (j.size){ $('#fwprog').max=j.size; $('#fwprog').value=j.rx||0; }
        }
      }else if (j.ev === 'end'){
        if (j.ok){
          $('#fwinfo').textContent = `Verify OK SHA=${j.sha}`;
          $('#fwprog').value = $('#fwprog').max;
          if ($('#autoApply').checked){ queue(async ()=>{ await send('FW:APPLY'); }); }
        }else{
          $('#fwinfo').textContent = `End ERR (rx=${j.rx}/${j.size})`;
        }
        stopVerifyPoll();
      }else if (j.ev === 'abort'){
        $('#fwinfo').textContent = `Aborted: ${j.reason||''}`;
        stopVerifyPoll();
      }else if (j.ev === 'apply'){
        $('#fwinfo').textContent = `Applying… rebooting`;
      }
      return; // fw 事件處理完就回
    }

    // 其他事件照舊…
    if (j.t === 'obd'){ /* …略，維持你原本的 rpm/maf/thr/map 更新 … */ }
    else if (j.t === 'raw'){ log(`RAW id=0x${j.id.toString(16)} d=${j.d}`); }
    else if (j.t === 'err'){ log(`ERR ${JSON.stringify(j)}`); }
    else if (j.t === 'info' && j.fw){ $('#ver').textContent=j.fw; log('FW '+j.fw); }
    else { log('RX '+s); }
  }catch(e){ log('RX '+s); }
}

/* ===== 手動上傳：END 後立刻送 STAT + 開啟輪詢 ===== */
async function fwUpload(){
  if (!chFILE || !device?.gatt?.connected){ log('未連線'); return; }
  const f = $('#fwfile').files[0];
  if (!f){ $('#fwinfo').textContent='請先選擇檔案'; return; }
  const target = ($('#fwpath').value || 'main.py').trim();

  const buf = await f.arrayBuffer();
  const sha = await sha256Hex(buf);
  const size = buf.byteLength;

  await send('PID:OFF'); await send('DUMP:OFF');
  await send(`FW:BEGIN ${target} ${size} ${sha}`);

  const u8 = new Uint8Array(buf);
  const CHUNK = isIOS()?20:180, GAP = isIOS()?50:8;
  const USE_WNR = (!isIOS()) && !!chFILE.writeValueWithoutResponse;

  $('#fwprog').max = size; $('#fwprog').value = 0;
  $('#fwinfo').textContent = `Uploading… 0/${size}`;
  await sleep(isIOS()?250:80);

  for (let i=0;i<u8.length;i+=CHUNK){
    const slice = u8.subarray(i, Math.min(i+CHUNK, u8.length));
    try{
      if (USE_WNR) await chFILE.writeValueWithoutResponse(slice);
      else         await chFILE.writeValue(slice);
      $('#fwprog').value = i + slice.length;
      if ((i % (CHUNK*50)) === 0) log(`FW up ${i + slice.length}/${size}`);
    }catch(e){
      $('#fwinfo').textContent = 'Write error: ' + e.message;
      log('FW write error: '+e.message);
      await send('FW:ABORT');
      return;
    }
    await sleep(GAP);
  }

  await sleep(isIOS()?700:250);
  await send('FW:END');
  $('#fwinfo').textContent = 'Upload done, verifying on device…';

  // 立刻詢問一次，再啟動輪詢
  await sleep(300);
  await send('FW:STAT');
  startVerifyPoll();
}

/* ===== 一鍵更新：END 後同樣 STAT + 輪詢 ===== */
async function oneClickUpdate(){
  try{
    if (!chRX || !chFILE || !device?.gatt?.connected){ log('請先 Connect'); return; }

    log('OTA: fetch manifest…');
    const mani = await fetchJSON(OTA_MANIFEST_URL);
    const {version, target, url, sha256} = mani;
    log(`OTA: latest ${version} → ${target}`);

    const base = new URL(OTA_MANIFEST_URL, location.href);
    const fwUrl = new URL(url, base).toString();
    log('OTA: download firmware… '+fwUrl);
    const resp = await fetch(fwUrl, {cache:'no-store'});
    if (!resp.ok) throw new Error('firmware HTTP '+resp.status);
    const buf = await resp.arrayBuffer();

    const sha = await sha256Hex(buf);
    if (sha.toLowerCase() !== String(sha256).toLowerCase()) throw new Error('SHA mismatch');
    log('OTA: SHA OK '+sha.slice(0,8)+'…');

    await send('PID:OFF'); await send('DUMP:OFF');
    const size = buf.byteLength;
    await send(`FW:BEGIN ${target} ${size} ${sha}`);

    const u8 = new Uint8Array(buf);
    const CHUNK = isIOS()?20:180, GAP = isIOS()?50:8;
    const USE_WNR = (!isIOS()) && !!chFILE.writeValueWithoutResponse;

    $('#fwprog').max = size; $('#fwprog').value = 0;
    $('#fwinfo').textContent = `Uploading… 0/${size}`;
    await sleep(isIOS()?250:80);

    for (let i=0;i<u8.length;i+=CHUNK){
      const slice = u8.subarray(i, Math.min(i+CHUNK, u8.length));
      if (USE_WNR) await chFILE.writeValueWithoutResponse(slice);
      else         await chFILE.writeValue(slice);
      $('#fwprog').value = i + slice.length;
      if ((i % (CHUNK*50)) === 0) log(`FW up ${i + slice.length}/${size}`);
      await sleep(GAP);
    }

    await sleep(isIOS()?700:250);
    await send('FW:END');
    $('#fwinfo').textContent = 'Upload done, verifying on device…';

    await sleep(300);
    await send('FW:STAT');
    startVerifyPoll();

  }catch(e){
    log('OTA ERR '+(e?.message||e));
    $('#fwinfo').textContent = 'OTA error: ' + (e?.message || e);
  }
}
</script>
